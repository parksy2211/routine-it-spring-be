name: Deploy to AWS EC2 (Improved)

on:
  workflow_run:
    workflows: ["Build and Push Docker Image"]
    types:
      - completed
    branches:
      - main
      - develop
      - test/*
  push:
    branches:
      - main
      - develop
    paths:
      - 'docker-compose.yml'
      - '.env.example'
      - '.github/workflows/deploy-to-aws-improved.yml'
  workflow_dispatch:
    inputs:
      deploy_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' || github.event_name == 'push' }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Set deployment tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.deploy_tag }}"
          else
            TAG="latest"
          fi
          echo "deploy_tag=$TAG" >> $GITHUB_OUTPUT
          echo "ğŸ·ï¸ Deploying tag: $TAG"

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          
          # Base64ë¡œ ì¸ì½”ë”©ëœ í‚¤ë¥¼ ë””ì½”ë“œ (GitHub Secretsì— Base64ë¡œ ì €ì¥í•œ ê²½ìš°)
          echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" | base64 -d > ~/.ssh/routine-it-key.pem
          
          # ì¼ë°˜ í…ìŠ¤íŠ¸ë¡œ ì €ì¥ëœ ê²½ìš° (ì´ ë¼ì¸ì€ ì£¼ì„ì²˜ë¦¬)
          # echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/routine-it-key.pem
          
          # ê¶Œí•œ ì„¤ì •
          chmod 600 ~/.ssh/routine-it-key.pem
          
          # SSH í‚¤ ê²€ì¦
          echo "ğŸ” Checking SSH key format..."
          head -n 1 ~/.ssh/routine-it-key.pem
          tail -n 1 ~/.ssh/routine-it-key.pem
          wc -l ~/.ssh/routine-it-key.pem
          
          # known_hosts ì„¤ì •
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null
          
          # SSH config ì„¤ì •
          cat >> ~/.ssh/config << EOF
          Host ec2-instance
            HostName ${{ secrets.EC2_HOST }}
            User ${{ secrets.EC2_USER }}
            IdentityFile ~/.ssh/routine-it-key.pem
            StrictHostKeyChecking no
            IdentitiesOnly yes
            PreferredAuthentications publickey
          EOF
          chmod 600 ~/.ssh/config
          
          echo "ğŸ” SSH setup completed"
          
          # SSH ì—°ê²° í…ŒìŠ¤íŠ¸
          echo "ğŸ§ª Testing SSH connection..."
          ssh -v -i ~/.ssh/routine-it-key.pem -o StrictHostKeyChecking=no ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "echo 'SSH connection successful!'" || {
            echo "âŒ SSH connection failed. Debug info:"
            echo "Host: ${{ secrets.EC2_HOST }}"
            echo "User: ${{ secrets.EC2_USER }}"
            echo "Key file exists: $(test -f ~/.ssh/routine-it-key.pem && echo 'Yes' || echo 'No')"
            echo "Key permissions: $(ls -la ~/.ssh/routine-it-key.pem)"
            exit 1
          }

      - name: Create .env file from secrets
        run: |
          cat > .env.production << EOF
          # Application
          APP_PORT=8080
          SPRING_PROFILES_ACTIVE=production
          
          # Database
          DB_HOST=routine-db
          DB_PORT=3306
          DB_NAME=${{ secrets.DB_NAME }}
          DB_USERNAME=${{ secrets.DB_USERNAME }}
          DB_PASSWORD=${{ secrets.DB_PASSWORD }}
          JPA_HIBERNATE_DDL_AUTO=${{ secrets.JPA_HIBERNATE_DDL_AUTO }}
          
          # Redis
          REDIS_HOST=routine-redis
          REDIS_PORT=6379
          REDIS_PASSWORD=${{ secrets.REDIS_PASSWORD }}
          
          # JWT
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          
          # OAuth2 Kakao
          KAKAO_CLIENT_ID=${{ secrets.KAKAO_CLIENT_ID }}
          OAUTH_REDIRECT_URI=${{ secrets.OAUTH_REDIRECT_URI }}
          OAUTH_CALLBACK_URI=${{ secrets.OAUTH_CALLBACK_URI }}
          
          # CORS
          CORS_ALLOWED_ORIGINS=${{ secrets.CORS_ALLOWED_ORIGINS }}
          
          # Logging
          LOG_LEVEL_SQL=${{ secrets.LOG_LEVEL_SQL }}
          LOG_LEVEL_SQL_BIND=${{ secrets.LOG_LEVEL_SQL_BIND }}
          LOG_LEVEL_APP=${{ secrets.LOG_LEVEL_APP }}
          
          # Docker
          DEPLOY_TAG=${{ steps.tag.outputs.deploy_tag }}
          
          # MySQL Root Password (for docker-compose)
          MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE=${{ secrets.DB_NAME }}
          EOF

      - name: Copy files to EC2
        run: |
          echo "ğŸ“¦ Copying deployment files to EC2..."
          
          # SSH í‚¤ ì‚¬ìš©í•˜ì—¬ ì§ì ‘ ì—°ê²°
          ssh -i ~/.ssh/routine-it-key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} "mkdir -p /home/${{ secrets.EC2_USER }}/routine-it-backend"
          
          # Copy docker-compose.yml
          scp -i ~/.ssh/routine-it-key.pem docker-compose.yml ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/routine-it-backend/
          
          # Copy .env file
          scp -i ~/.ssh/routine-it-key.pem .env.production ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }}:/home/${{ secrets.EC2_USER }}/routine-it-backend/.env
          
          echo "âœ… Files copied successfully"

      - name: Deploy to EC2
        run: |
          echo "ğŸš€ Starting deployment to EC2..."
          
          ssh -i ~/.ssh/routine-it-key.pem ${{ secrets.EC2_USER }}@${{ secrets.EC2_HOST }} << 'ENDSSH'
            set -e
            
            echo "ğŸ“‚ Navigating to application directory..."
            cd /home/${{ secrets.EC2_USER }}/routine-it-backend
            
            # Backup current .env if exists
            if [ -f .env ]; then
              cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
              echo "ğŸ“‹ Backed up existing .env file"
            fi
            
            echo "ğŸ“¥ Pulling latest Docker images..."
            export DEPLOY_TAG=${{ steps.tag.outputs.deploy_tag }}
            docker-compose pull
            
            echo "ğŸ”„ Restarting application..."
            docker-compose down --remove-orphans
            docker-compose up -d
            
            echo "â³ Waiting for application to be ready..."
            for i in {1..30}; do
              if curl -f http://localhost:8080/api/health/ping > /dev/null 2>&1; then
                echo "âœ… Application is healthy!"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "âŒ Application failed to start within 5 minutes"
                docker-compose logs --tail=50
                exit 1
              fi
              echo "â³ Waiting... ($i/30)"
              sleep 10
            done
            
            echo "ğŸ§¹ Cleaning up old Docker images..."
            docker image prune -f
            
            echo "ğŸ“Š Deployment status:"
            docker-compose ps
            
            echo "ğŸ” Environment variables loaded:"
            docker-compose exec -T app env | grep -E "^(SPRING_|DB_|REDIS_|JWT_|KAKAO_)" | sort
          ENDSSH

      - name: Health Check
        run: |
          echo "ğŸ” Running post-deployment health checks..."
          
          curl -f http://${{ secrets.EC2_HOST }}:8080/api/health/ping || {
            echo "âŒ Health check failed"
            exit 1
          }
          
          echo "âœ… All health checks passed!"

      - name: Notify deployment success
        if: success()
        run: |
          echo "ğŸ‰ Deployment completed successfully!"
          echo "ğŸŒ Application is available at: http://${{ secrets.EC2_HOST }}:8080"
          echo "ğŸ“š API Documentation: http://${{ secrets.EC2_HOST }}:8080/swagger-ui/index.html"